<!DOCTYPE html>
<html lang="en">

  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-126715006-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-126715006-1');
</script>

    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap 4 -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <link rel="stylesheet" href="bootstrap.min.css">
    <!-- work CSS -->
    <link rel="stylesheet" href="work_detail.css">
    <link rel="stylesheet" href="../mqueries.css">
    <!-- roboto mono font -->
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
    <!-- favicon -->
    <link rel='icon' href='../favicon.png' type='image/x-icon'>

    <title>Burrows-Wheeler - Kevin Feng</title>

  </head>

  <body>

    <div class="row no-1">

      <div class="col-xs-2 col-md-2">

        <div id="home-sig-container">
          <a href="/">
             <img class="initials" src="../initials.svg">
            </a>
        </div>

        <div id="holy-trinity">
          <p>Design,<br>Code,<br>and HCI</p>
        </div>
      </div>

      <div class="social">

        <div class="col" style="text-align:right">

          <p>
            <a href="mailto:kevin.feng@live.ca" target="_blank">Email</a><br>
            <a href="https://www.linkedin.com/in/kevin-kj-feng/" target="_blank">LinkedIn</a><br>
            <a href="https://medium.com/@kjfeng" target="_blank">Medium</a><br>
            <a href="https://are.na/kevin-feng" target="_blank">Are.na</a><br>
            <a href="https://github.com/kjfeng" target="_blank">Github</a><br>
            <a href="https://twitter.com/feng_kj" target="_blank">Twitter</a>
          </p>

        </div>
      </div>

    </div>

    <div class="row no-2">
      <div class="col-xs-2 col-md-2">

        <div id="nav-links">
          <p>
            <a href="/work" style="color: #636363">Work</a><br>
            <a href="/readings">Readings</a><br>
            <a href="https://medium.com/kevin-feng-blog" target="_blank">Blog</a><br>
            <a href="/k_feng_RESUME.pdf" target="_blank">Resume</a>
          </p>
        </div>
      </div>

      <div class="col-xs-12 col-md-8">
        <div id="heading">
          <h1>Burrows-Wheeler Data Compression</h1>
        </div>
        <div class="subheading">
          <h1>Java<br>Spring 2018</h1>
        </div>
        <div class="writeup">

          <h2>Overview</h2>
          <p>The Burrows-Wheeler data compression algorithm forms the basis of Unix compression utility <a href="http://www.bzip.org/">bzip2</a>. It outcompresses gzip and PKZIP and is not protected by any patents. The algorithm comprises of three algorithmic components, which are applied in succession:</p>

          <p><strong>Burrows–Wheeler transform:</strong> transform a typical English text file into a text file in which sequences of the same character occur near each other many times.</p>

          <p><strong>Move-to-front encoding:</strong> converts a text file in which sequences of the same character occur near each other many times into a text file in which certain characters appear more frequently than others. This order makes for more efficient compression.</p>

          <p><strong>Huffman compression:</strong> compress a text file in which certain characters appear more frequently than others by encoding frequently occurring characters with short codewords and infrequently occurring characters with long codewords.</p>
          
          <p>I implemented the Burrows-Wheeler data compression algorithm by using the Huffman algorithm provided by <i>Algorithms, 4th Edition</i> by Sedgewick and Wayne and writing the move-to-front encoding/decoding as well as Burrows-Wheeler transform and inverse transform components. </p>
          
          <h2>Approach</h2>
          
          <p>To implement move-to-front encoding and decoding, I kept an ordered sequence of the 256 extended ASCII characters in an array, where the <tt>I</tt>th index in the array corresponded to the <tt>I</tt>th extended ASCII character. Next, I read each 8-bit character from the input string one at a time. For encoding, the index corresponding to the read character was written to output, and the character was moved to the front of the sequence. For decoding, the character was casted to its integer representation, and character indexed at that integer was written to output while the character itself was moved to the front of the sequence.</p>

          <p>Next, to implement the Burrows-Wheeler transform, I created a circular array that is an abstraction of a sorted array of <tt>n</tt> circular prefixes of a string of length <tt>n</tt> (it’s an abstraction to avoid storing all <tt>n</tt> sorted prefixes to optimize memory and performance). The circular array was then used as the main mechanism of the Burrows-Wheeler transform to write the correct characters to output using the results of move-to-front encoding. </p>

          <p>I then implemented an inverse Burrows-Wheeler transform, which was a little trickier and more interesting to think about. Since I had the sorted prefix array I created earlier, I can map the rows in which the non-sorted prefixes appear to the sorted rows. Once I figured out these mappings, it was possible to establish a connection between the transformed and original strings. Upon storing the mappings and then using key-indexed counting to sort the mappings, I obtained an array of characters that matched the original string as a by-product of the sorting operation.</p>

          <h2>Conclusion</h2>
          <p>After running some timing tests and comparing the compression times and ratios of gzip and Burrows-Wheeler, I concluded that generally speaking, the encoding and decoding time in gzip is much faster but the compression ratio is inferior to Burrows-Wheeler on very small texts and very large texts. For anything in the middle, the compression ratio between the two algorithms are comparable.</p>

          <p>This assignment makes use of standard libraries from the course. All code from this assignment is currently stored on a private Github repository due to course policies and may be available upon special request.</p>

        </div>
      </div>
    </div>


  </body>

</html>
